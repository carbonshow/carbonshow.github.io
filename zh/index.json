[{"content":"   小虫飞飞大本营 折腾了一段时间终于搞定了，虽然简陋但总算有个落脚的地方。开荒时遇到了不少问题，记录下来，算是一种纪念吧。  初衷   搭建个人技术博客，目的有两个：    知识整理。在工作或者闲暇时，大家总会遇到各种问题和感兴趣的技术点。俗话说好记性不如烂笔头，及时归纳总结有助回顾。这样一种情况想必大家遇到过：某个问题心里很清楚，但讲出来时发现不够周密，有遗漏。这正应了费曼学习法 ：用写作、讲授来倒逼学习。    以“技”会友。独乐不如众乐，有交流探讨才能更快成长。更多人看到，就会有更多人评价，不仅有助于发现自己的纰漏，也能帮助更多的人少走弯路。    为了实现上面的目标， 小虫 做了一遍调研，发现有以下几种途径：    微信公众号。传播便捷，内容质量要求高，还能有收益。    现成的博客平台。耳熟能详的有：CSDN，简书，博客园；近几年兴起的：掘金，SegmentFault；问答形式的知识平台：知乎等。它们的好处是：    体系成熟。无论是编辑，查询，搜索，互动，收益，一应俱全。    搜索引擎友好。基本都做到了极致，这意味着可以跳脱出固有圈子，让更多人阅读。      自己搭建。最大的好处是树立个人品牌，代价是——全部从零开始：服务器，域名，备案，数据库，后台进程等一整套。当然现在也有不少云服务商提供配套解决方案，比如：阿里，腾讯，netlify 等。这应该是最难走的一条路，但也是不少技术大牛采取的方式。    基于已有静态页面托管平台。典型例子就是 github ，域名和服务器都有，只缺内容。    经过评估，小虫最终决定从静态页面开始，把心思聚焦在内容上，等真正有所积累再慢慢向外推广。那么问题剩下两个：    选择一个静态页面生成工具    选择一个页面托管平台   静态页面生成器   简称 SSG(Static Site Generator)，简而言之一句话：让作者把精力聚焦在内容上，将 Markup 语言写出的普通文本转化为丰富多彩的 web 页面。这个需求可以说直击广大技术宅的痛点，您瞧现有的成熟解决方案就多达 400+ 。2019最佳的10个SSG ，再加上国内大名鼎鼎的 hexo 基本补全了优秀候选列表。 小虫 最终选择了 hugo ，原因很简单：    基于 go 开发，一个二进制就行，没有错综复杂的依赖关系。    社区活跃。这点很重要，用的人越多，解决方案也就更多。    功能完善。前端语言支持的种类丰富，比如 小虫 习惯使用的 Org-Mode ，已经内置支持；整体框架灵活易懂，比如文档分类，多语言，主题，内置 shortcode 支持更强大的表现力等；修改即时预览；一键部署等。    说了这么多还是直接上图吧，我们期望的就是： 些普通文本，看 web 页面  源文本演示:    本文基于 Emacs 使用 Org-Mode 编写，所有内容均来自于该文件，生成的 web 页面就是您当前看到的：  Web 页面展示:    官网有快速开始的详细说明， 小虫 以自己的实际情况为例，介绍重点。 安装及创建   Mac  安装\n1  brew install hugo   创建新网站，根目录：小虫飞飞\n1  hugo new site 小虫飞飞       'use strict'; var containerId = JSON.parse(\"\\\"d5cc742a70f05b46\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  配置   hugo 框架完善且庞大，如果根据文档逐条学习，虽然可以获得整体认识，但在实际应用中依然会碰到很多问题。因为不同主题在 hugo 基础上多多少少做了些个性化的封装，且使用方式差异较大。所以 小虫 建议： 先选主题，在主题框架内学习配置 。与实践结合，提高了学习效率。 主题挑选可以在 Hugo主题官网 查阅， 小虫 使用的是 zzo 。下面以 zzo 为例简述使用过程：  zzo  安装主题 1  git submodule add ttps://github.com/zzossig/hugo-theme-zzo.git themes/zzo   参考示例配置自己的工程 1 2 3  cp -rf themes/zzo/exampleSite/config . cp -rf themes/zzo/exampleSite/content . cp -rf themes/zzo/exampleSite/static .   修改基本信息和默认语言：config/_default/config.toml 1 2 3 4  baseURL = \u0026#34;https://carbonshow.github.io\u0026#34; title = \u0026#34;小虫飞飞\u0026#34; theme = \u0026#34;zzo\u0026#34; defaultContentLanguage = \u0026#34;zh\u0026#34;   多语言配置，仅保留中英文：config/_default/languages.toml 1 2 3 4 5 6 7 8 9 10 11 12 13  [zh] title = \u0026#34;小虫飞飞大本营\u0026#34; languageName = \u0026#34;中文\u0026#34; languageDir = \u0026#34;ltr\u0026#34; contentDir = \u0026#34;content/zh\u0026#34; weight = 1 [en] title = \u0026#34;小虫飞飞大本营\u0026#34; languageName = \u0026#34;English\u0026#34; languageDir = \u0026#34;ltr\u0026#34; contentDir = \u0026#34;content/en\u0026#34; weight = 2   菜单栏配置，每种语言一个，以中文为例： menus.zh.toml 1 2 3 4 5 6 7 8 9 10 11  [[main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;关于\u0026#34; url = \u0026#34;about\u0026#34; weight = 1 [[main]] identifier = \u0026#34;posts\u0026#34; name = \u0026#34;探险笔记\u0026#34; url = \u0026#34;posts\u0026#34; weight = 2   内容目录配置 content 目录下保存博客的实际内容，每种语言一个子目录。可以将 ko 重命名为 cn 。\n注意每个目录中的 _index.md 是对该模块的整体配置，可以参考注释结合自己需要修改。\n运行本地查看：http://localhost:1313 1  hugo server -D       'use strict'; var containerId = JSON.parse(\"\\\"40e1a420aecae4c2\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  静态页面托管——Github   利用 Github Pages 托管并展示生成的静态页面，做到了提交后立即生效，非常适合 git 用户。 Pages 有两种类型：    面向用户和组织    面向具体工程    博客是一个平台，内容比较丰富可能并不针对某个具体的工程，所以选择前者。基本流程如下所示。 Step 1: Github 创建自己的账号 貌似是废话，github 官网直接注册即可， 小虫 的账号是 carbonshow ，后面以此为例展开介绍。 Step 2: Github 创建第一个 repository ，用来保存 =hugo= 工程，比如：mylog 创建 blog 仓库:   创建完毕后，clone 到本地然后按照上面的介绍建立 hugo 工程。 1  git clone https://github.com/carbonshow/myblog.git     内容完成后大概是这个样子： blog 结构预览:   Step 3: Github 创建第二个 repository ，用来保存 静态页面 也就是对外展示的页面，仓库名建议采用： username.github.io 的形式，比如 carbonshow.github.io Step 4: 本地进入 myblog 目录，将 carbonshow.github.io 以 submoudle 的形式添加到 public 子目录中保存生成的页面。 1  git submodule add -b master https://github.com/carbonshow/carbonshow.github.io.git public     Step 5: myblog 目录内运行 hugo 会生成页面到 public 目录中。进入该目录提交并 push 到远程仓库。 Step 6: 生成和提交过程可以简化为 bash 脚本，将下述代码放入 deploy.sh 文件执行即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master     Step 7: 登陆 https://carbonshow.github.io 就可以看到想要的内容啦 小结   上面介绍了基本流程，核心还是内容的创作。希望大家都能顺利搭建，然后愉快地开始码字吧。哦，顺便推荐个制作 icon 的网站：https://www.favicon-generator.org/ ，一张图片就能转化成针对不同平台的适配图，且和 zzo 主题无缝对接，大家可以试试哦。 ","description":"使用 Hugo 将 Markup 文档转化为静态页面，并通过 github 托管展示","id":0,"section":"posts","tags":["hugo","github","blog"],"title":"基于hugo 在github 上搭建个人博客","uri":"https://carbonshow.github.io/zh/posts/hugo_github/"},{"content":"   Pandas 是 Python 界最流行的数据统计基础库之一。但像我这样和 Java/Scala 打交道的人，还是期望 JVM 有类似的解决方案。网上一搜发现生态还是很丰富的：大数据领域的 Spark ，支持 GUI 的数据挖掘套件 weka ，主攻机器学习的 smile ，擅长聚合变换的 joinery 等等。但小虫最终还是选择了简约而不简单的 tablesaw 。缘由还得从那句老话说起： 离开场景谈应用都是耍流氓 。  应用场景  数据：处理流程   工作环境:   小虫在工作中使用 Spark 将业务产生的海量用户行为按模块加工：过滤冗余/简单汇总，并导出至 PostgreSQL 的不同表中，存储正交化的基础数据。比如用户的登陆/购买行为分别记录到， LoginTable 和 ShoppingTable 。然后在 二次处理 模块中建立不同服务，比如 S1，S2。S1 直接访问数据库，S2 的既要访问数据库，又要访问 S1 的统计结果，还要依赖本地的 csv 文件。 计算需求分类     查询计算。整表查询，列的统计，变换等。    筛选排序。条件查询，自定义多重排序等。    聚合连接。比如 LoginTable 记录终端类型：android/iOS； ShoppingTable 记录了用户购买物品的种类和数量。当要对比不同终端用户购买行为差异时，就要将两个表连接并按终端类型聚合。    模型验证。评估决策需要的分析模型多变，要经过反复调整得到最终结果。关键在于 快速迭代 。   特点汇总     纬度 特点 说明     数据量 较小单机可承载 原始数据由 spark 汇总   格式 数据库，本地 csv，json json 多来自于 restful 服务   计算 增删改查，条件查询，表连接，聚合，统计 内置算子越多，扩展性越高越好   交互 输出到指定格式，可视化，可交互 等 网页渲染，终端，Jupyter Notebook   集成 轻量，以库而非服务的形式 便于嵌入进程和其他逻辑交互    为何选择 tablesaw   很简单，就因为它完美契合小虫的应用场景。借用 tablesaw官网 的特性列表：    数据导入：RDBMS，Excel，CSV，Json，HTML 或固定宽度文件。除了支持本地访问，还支持通过 http，S3 等远程访问。    数据导出：CSV，Json，HTML 或固定宽度文件。    表格操作：类似 Pandas DataFrame ，增删改查，连接，排序。    以上是基础功能，小虫觉得下面几个点更有意思：    基于Plotly 的可视化框架。摆脱 java 的 UI 系统，更好的和 Web 对接。支持 2D、3D 视图，图表类型也很丰富：曲线，散点，箱形统计，蜡烛图，热力图，饼状图等。更重要的是：    交互式图表。特别适合多种数据集对比，以及三维视角旋转。    图表导出为字符串形式 Javascript 。方便结合 Web Service 渲染 html。      与 smile 对接。tablesaw 可将表格导出为 smile 识别的数据格式，便于利用其强大的机器学习库。    好了，说了这么多，直接上干货吧。 基本应用  安装   tablesaw 包含多个库，小虫推荐安装 tablesaw-core 和 tablesaw-jsplot 。前者是基础库，后者用于渲染图表。其它如 tablesaw-html, tablesaw-json, tablesaw-breakerx 主要是对数据格式变化的支持，可按需选择。其实结合需求写两行代码就行，轻量又灵活。以 tablesaw-core 为例说明 Jar 包安装方法：  maven sbt  1 2 3 4 5 6  \u0026lt;!--https://mvnrepository.com/artifact/tech.tablesaw/tablesaw-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;tech.tablesaw\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tablesaw-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.37.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     1 2  // https://mvnrepository.com/artifact/tech.tablesaw/tablesaw-core libraryDependencies += \u0026#34;tech.tablesaw\u0026#34; % \u0026#34;tablesaw-core\u0026#34; % \u0026#34;0.37.3\u0026#34;       'use strict'; var containerId = JSON.parse(\"\\\"7f4b56055ca67724\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  表格创建   两种基本方式：    从数据源读取直接创建    创建空表格编码增加列或行    表格创建流程:    下面先定义需要处理的 csv 文件格式。第一列为日期，第二列为姓名，第三列为工时（当日工作时长，单位是小时），第四列为报酬（单位是元）。然后举三个典型例子来说明导入的不同方式。 1. CSV 直接导入  1 2 3 4 5 6 7 8  // 读取csv文件input.csv 自动推测schema val tbl = Table.read().csv(\u0026#34;input.csv\u0026#34;) // 产看读入的表格内容 println(tbl.printAll()) // 查看schema println(tbl.columnArray().mkString(\u0026#34;\\n\u0026#34;))     输出表格内容为：    date name 工时 报酬     2019-01-08 tom 8 1000   2019-01-09 jerry 7 500   2019-01-10 张三 8 999   2019-01-10 jerry 8 550   2019-01-10 tom 8 1000   2019-01-11 张三 6 800   2019-01-11 李四 12 1500   2019-01-11 王五 8 900   2019-01-11 tom 6.5 800     可以发现能够比较完美的推测，并对中文支持良好。输出 schema 为： Date column: date\nString column: name\nDouble column: 工时\nInteger column: 报酬 tablesaw 目前支持的数据类型有以下几种：SHORT, INTEGER, LONG ,FLOAT ,BOOLEAN ,STRING ,DOUBLE ,LOCAL_DATE ,LOCAL_TIME ,LOCAL_DATE_TIME ,INSTANT, TEXT, SKIP。绝大部分列和普通数据表类型没有差异，为一需要强调的是：    INSTANT。可以精确到纳秒的时间戳，自 Java 8 引入。    SKIP。指定列忽略不读入。   2. 指定 schema 从 CSV 导入   有时自动推测并不会非常精准，比如期望使用 LONG ，但识别为 INTEGER ；或在读入后追加数据时类型会有变化，比如报酬读入是整型但随后动态增加会有浮点数据。这时就需要预先设定 csv 的 schema ，这时可以利用 tablesaw 提供的 CsvReadOptions 实现。比如预先设置报酬为浮点： 1 2 3 4 5 6 7 8 9 10  import tech.tablesaw.api.ColumnType import tech.tablesaw.io.csv.CsvReadOptions // 按序指定csv 各列的数据类型 val colTypes: Array[ColumnType] = Array(ColumnType.LOCAL_DATE, ColumnType.STRING, ColumnType.DOUBLE, ColumnType.DOUBLE) val csvReadOptions = CsvReadOptions.builder(\u0026#34;demo.csv\u0026#34;).columnTypes(colTypes) val tbl = Table.read().usingOptions(csvReadOptions) // 查看schema println(tbl.columnArray().mkString(\u0026#34;\\n\u0026#34;))     输出 schema 为： Date column: date\nString column: name\nDouble column: 工时\nDouble column: 报酬 3. 编码设定 schema 和数据填充   该方法适合各种场景，可以运行时从不同数据源导入数据。 基本流程是：\n 创建空表格，同时设定名称 设定 schema：向表格中按序增加指定了 =名称= 和 =数据类型= 的列。 向表格中按行追加数据。每行中的元素分别添加到指定列中。  将之前的例子做些变化，假设数据来自于网络，序列化到本地内存的数据结构为： 1 2  // 以case class 的形式定义数据源转化到本地的内存结构 case class RowData(date: LocalDate, name: String, workTime: Double, salary: Double)     创建一个函数将获取的数据集合添加到表格中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // @param tableName 表格名称 // @param colNames 表格各列的名称列表 // @param colTypes 表格各列的数据类型列表 // @param rows 列数据 def createTable(tblName: String, colNames: Seq[String], colTypes: Seq[ColumnType], rows: Seq[RowData]): Table = { // 创建表格设定名称  val tbl = Table.create(tblName) // 创建schema ：按序增加列  val colCnt = math.min(colTypes.length, colNames.length) val cols = (0 until colCnt).map { i =\u0026gt; colTypes(i).create(colNames(i)) } tbl.addColumns(cols: _*) // 添加数据  rows.foreach { row =\u0026gt; tbl.dateColumn(0).append(row.date) tbl.stringColumn(1).append(row.name) tbl.doubleColumn(2).append(row.workTime) tbl.doubleColumn(3).append(row.salary) } tbl }     上面的说明了数据添加的完整过程：创建表格，增加列，列中追加元素。基于这三个基本操作基本可以实现所有的创建和形变。 列处理   列操作是表格处理的基础。前面介绍了列的数据类型，名称设置和元素追加，下面继续介绍几个基础操作。 1. 遍历与形变   比如按序输出 demo 表格中所有记录的姓名： 1 2 3 4 5 6 7 8 9 10  // 获取姓名列，根据列名索引 val nameCol = tbl.stringColumn(\u0026#34;name\u0026#34;) // 根据行号遍历 (0 until nameCol.size()).foreach( i =\u0026gt; println(nameCol.get(i)) ) // 直接使用column 提供的遍历接口 nameCol.forEacch(println)     除了遍历外，另一种常见应用是将列形变到另外一列：类型不变值变化；类型变化。以工时为例，我们将工时不小于 8 则视为全勤： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 根据列的索引获取工时一列 val workTimeCol = tbl.doubleColumn(2) // 形变1: map，输出列类型与输入列保持一致 val fullTimeCol = workTimeCol.map { time =\u0026gt; // 工时类型是Double，因此需要将形变结果也转化为 Double，否则编译失败  if (time \u0026gt;= 8) 1.0 else 0.0 } // 形变 2: mapInto，输入/输出列的数据类型可以不同，但需提前创建大小相同的目标列 val fullTimeCol = BooleanColumn.create(\u0026#34;全勤\u0026#34;, workTimeCol.size()) // 创建记录全勤标签的Boolean列 val mapFunc: Double2BooleanFunction = (workTime: Double) =\u0026gt; workTime \u0026gt;= 8.0 // 基于SAM 创建映射函数 workTimeCol.mapInto(mapFunc, fullTimeCol) // 形变 tbl.addColumns(fullTimeCol) // 将列添加到表格中     输出结果为：    date name 工时 报酬 全勤     2019-01-08 tom 8 1000 true   2019-01-09 jerry 7 500 false   2019-01-10 张三 8 999 true   2019-01-10 jerry 8 550 true   2019-01-10 tom 8 1000 true   2019-01-11 张三 6 800 false   2019-01-11 李四 12 1500 true   2019-01-11 王五 8 900 true   2019-01-11 tom 6.5 800 false    2. 列运算   tablesaw 提供了丰富的针对列的运算函数，而且针对不同数据类型提供了不同特化接口。建议优先查阅 API 文档，最后考虑写代码。这里介绍几个大类：    多列交叉运算。比如一列中所有元素和同一数据计算，或者两列元素按序交叉计算。比如每人的时薪：   1 2  // 第三列报酬除以第二列工时得到时薪 tbl.doubleColumn(3).divide(tbl.doubleColumn(2))       单列的统计。均值，标准差，最大 N 个值，最小 N 个值，窗口函数等。   1 2  // 第三列报酬的标准差 tbl.doubleColumn(3).workTimeCol.standardDeviation()       排序。数值，时间，字符串类型默认支持增序、降序，也支持自定义排序。   3. 过滤   tablesaw 对列的过滤条件定义为 Selection ，不同的条件可以按“与、或、非”组合。每种类型的列均提供 \u0026#34;is\u0026#34; 作为前缀的接口直接生成条件。下面举个例子，找到工作时间在 2019-01-09 - 2019-01-10 之间工时等于 8 且报酬小于 1000 的所有记录： 1 2 3 4 5 6 7 8 9 10 11  // 设置时间的过滤条件 val datePattern = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;) val dateSel = tbl.dateColumn(0) .isBetweenIncluding(LocalDate.parse(\u0026#34;2019-01-09\u0026#34;, datePattern), LocalDate.parse(\u0026#34;2019-01-10\u0026#34;, datePattern)) // 设置工时过滤条件 val workTimeSel = tbl.doubleColumn(2).isEqualTo(8.0) // 设置报酬过滤条件 val salarySel = tbl.doubleColumn(3).isLessThan(1000) // 综合各条件过滤表格 tbl.where(dateSel.and(workTimeSel).and(salarySel))     输出结果符合预期：    date name 工时 报酬 全勤     2019-01-10 张三 8 999 true   2019-01-10 jerry 8 550 true    表格处理   除了基础操作可以参考官网说明外，有三种表格的操作特别值得一提：连接，分组聚合，分表。 连接   将有公共列名的两个表连接起来，基本方式是以公共列为 key，将各表同行其它列数据拼接起来生成新表。根据方式的不同组合有所差异：    inner. 公共列中的数据取交集，其他过滤。    outer. 公共列中的数据取并集，缺失的数据设置默认空值。具体又可以分为三类：    leftOuter. 结果表公共列数据与左侧表完全相同，不在其中的过滤，缺失的设置空值。    rightOuter. 结果表公共列数据与右侧表完全相同，不在其中的过滤，缺失的设置空值。    fullOuter. 结果表公共列数据为两个表的并集，缺失的设置空值。      举个例子，增加一个新表 tbl2 记录每人的工作地点：    name 地点     张三 总部   李四 门店 1   王五 门店 2     采用 inner 方式和 demo 表连接： 1  val tbl3 = tbl.joinOn(\u0026#34;name\u0026#34;).inner(tbl2)     tbl3 的内容是：    date name 工时 报酬 全勤 地点     2019-01-10 张三 8 999 true 总部   2019-01-11 张三 6 800 false 总部   2019-01-11 李四 12 1500 true 门店 1   2019-01-11 王五 8 900 true 门店 2     可以发现，按照 name 的交集连接，tom 和 jerry 都被过滤掉了。 分组聚合   类似于 SQL 中的 groupby，接口为： tbl.summarize(col1, col2, col3, aggFunc1, aggFunc2 ...).by(groupCol1, groupCol2) 。其中 by 的参数表示分组列名集合。summarize 的 col1, col2, col3 表示分组后需要被聚合处理的列名集合， aggFunc1, aggFunc2 表示聚合函数，会被用于所有的聚合列。举个例子计算每人的总报酬： 1  tbl3.summarize(\u0026#34;报酬\u0026#34;, sum).by(\u0026#34;name\u0026#34;)       name Sum [报酬]     tom 2800   jerry 1050   张三 1799   李四 1500   王五 900    分表   和分组聚合不同，按列分组后，可能并不需要将同组数据聚合为一个值，而是要保存下来做更加复杂的操作，这时就需要分表。接口很简单： tbl.splitOn(col ...) 设定分表的列名集合。比如： 1 2  // 按照名称和地点分表，并将生成的各个子表保存到 List 中 tbl.splitOn(\u0026#34;name\u0026#34;, \u0026#34;地点\u0026#34;).asTableList()    可视化   tablesaw 可以将表格导出为交互式 html，也支持调试时直接调研调用浏览器打开，并针对不同类型图表做了个性化封装。举个简单例子，查看每人报酬的时间变化曲线： 1 2 3 4  //含义是：将tbl 按照 name 列分组，以 date 列为时间轴，显示 报酬 的变化曲线 //并将图表的名称设置为：薪酬变化曲线 val fig = TimeSeriesPlot.create(\u0026#34;薪酬变化曲线\u0026#34;, tbl, \u0026#34;date\u0026#34;, \u0026#34;报酬\u0026#34;, \u0026#34;name\u0026#34;) Plot.show(fig)     薪酬变化曲线:   其它类型的图表还有很多，使用方法大同小异，只需根据官方文档传入正确参数即可。 小结   小虫向大家简单介绍了 tablesaw 的功能和使用方法，从我自己的使用经验而言，我最喜欢它的的地方在于：    api 接口的统一，清晰    交互式图表生成简单，能够和 web 对接    此外， tablesaw 的开发和维护也如火如荼，期待后续有更多的有趣的功能添加进来。 ","description":"jvm中数据表分析/展示利器","id":2,"section":"posts","tags":["pandas","jvm","scala","dataframe"],"title":"JVM上的Pandas：tablesaw","uri":"https://carbonshow.github.io/zh/posts/tablesaw/"},{"content":" 主要内容   小虫飞飞大本营 以 技术 为主要话题，将笔者在日常工作、无聊闲逛中遇到的有趣内容整理出来。一方面帮助自己归纳总结，一方面期待给更多朋友带来有益的思考。内容主要包含以下几类：    编程语言。当前主流语言如： jvm系 , C/C++ , C# , Python , Golang 等；也包含一些小众但在具体领域有专长的语言，比如： Lisp , R 等。    分布式系统。包含架构设计，组件应用，网络底层通信，服务治理，CAP 问题解决等。    大数据处理。海量数据离线、实时计算的解决方案，具体结合 spark/storm/flink 介绍底层原理和实际应用。    机器学习和推荐系统。网络中关于基础算法和内容有丰富资源， 小虫 会侧重于实际问题的思路和解决方案。    工具。大家看博客，撸代码都是为了增长学识和能力。除了专业技能自身，学习的方法、使用的工具也很重要。 小虫 会将业界反馈良好的利器分享出来，结合具体场景描述利弊。   关于小虫   也许有人好奇，技术死宅为什么会起一个 小虫飞飞 的称号，故意卖萌吗？对啊，彪形大汉内心不能是一个小白兔吗？其实。。。。。。。。。。真的不是这样的。 小虫 主要还是来自年幼时两段深刻的记忆：    《水浒传》。特别是武松打虎这一段，其中关于老虎描述是：云生从龙，风生从虎。龙嘛比较虚幻，虎则是切实存在的兽中之王。因此特别想 \u0026#34;狐假虎威\u0026#34; ，不过还是要含蓄点，所以取名众梁山好汉口中的： 大虫 。    一部动画片的主题曲：有一只小蜜峰，飞到西呀飞到东，嗡嗡嗡嗡，嗡嗡嗡嗡，不怕雨也不怕风。很朴实简单，但却塑造了一个勇敢、不畏艰险的英雄形象。这时我才知道，身形的大小不重要，关键在：态度和坚持。    技术本来就艰深复杂，但同样充满乐趣。大家几乎都有过被bug 折腾得死去活来的惨痛经历，那种百思不得其解的体验就像是丛林中迷途的蚂蚁。但总有柳暗花明的时候，也许一个转瞬即逝的小想法就像萤火虫给黑暗的旅途带来光明，令人豁然开朗。这种舒爽相必也是大家负重前行的动力之一吧。  总之，希望 小虫 能伴您一起在技术丛林中探险，也许 99% 的过程都很枯燥乏味，但只要有那1% 的收获也就不负此行了吧。 ","description":"关于小虫飞飞大本营内容和背景的简单介绍","id":3,"section":"","tags":null,"title":"关于","uri":"https://carbonshow.github.io/zh/about/"}]